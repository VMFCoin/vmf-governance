import { renderHook, act } from '@testing-library/react';
import { useProposalStore } from '@/stores/useProposalStore';
import { useUserStore } from '@/stores/useUserStore';
import { useCharityStore } from '@/stores/useCharityStore';
import { useHolidayStore } from '@/stores/useHolidayStore';
import { ProposalType, CharityDirectoryProposal } from '@/types';

// Mock console to suppress error logs during tests
const originalConsoleError = console.error;
const originalConsoleWarn = console.warn;

describe('Store Error Handling', () => {
  beforeEach(() => {
    // Clear localStorage to reset stores
    localStorage.clear();

    // Suppress console errors and warnings during tests
    console.error = jest.fn();
    console.warn = jest.fn();
  });

  afterEach(() => {
    // Restore console methods
    console.error = originalConsoleError;
    console.warn = originalConsoleWarn;
    jest.clearAllMocks();
  });

  describe('ProposalStore Error Handling', () => {
    it('should handle null/undefined proposal additions', () => {
      const { result } = renderHook(() => useProposalStore());

      expect(() => {
        act(() => {
          result.current.addProposal(null as any);
        });
      }).not.toThrow();

      expect(() => {
        act(() => {
          result.current.addProposal(undefined as any);
        });
      }).not.toThrow();

      // Store should remain stable
      expect(result.current.proposals).toBeDefined();
    });

    it('should handle malformed proposal data', () => {
      const { result } = renderHook(() => useProposalStore());

      const malformedProposal = {
        id: 'test-malformed',
        // Missing required fields
        type: 'invalid_type' as any,
        title: null,
        author: undefined,
        status: 'invalid_status' as any,
      };

      expect(() => {
        act(() => {
          result.current.addProposal(malformedProposal as any);
        });
      }).not.toThrow();

      // Store should handle malformed data gracefully
      expect(result.current.proposals).toBeDefined();
    });

    it('should handle proposals with missing required fields', () => {
      const { result } = renderHook(() => useProposalStore());

      const incompleteProposal = {
        id: 'incomplete-test',
        type: 'charity_directory',
        // Missing other required fields
      };

      expect(() => {
        act(() => {
          result.current.addProposal(incompleteProposal as any);
        });
      }).not.toThrow();
    });

    it('should handle moderate proposal datasets', () => {
      const { result } = renderHook(() => useProposalStore());

      // Create a moderate dataset (reduced from 10000 to 100)
      const proposalSet = Array.from({ length: 100 }, (_, i) => ({
        id: `proposal-${i}`,
        type: 'charity_directory' as const,
        title: `Proposal ${i}`,
        author: `Author ${i}`,
        status: 'active' as const,
        timeLeft: '7 days',
        yesPercentage: 50,
        noPercentage: 30,
        abstainPercentage: 20,
        createdAt: new Date(),
        votingEndsAt: new Date(),
        isAutoGenerated: false,
        votingType: 'approval' as const,
      }));

      expect(() => {
        act(() => {
          proposalSet.forEach(proposal => {
            result.current.addProposal(proposal as any);
          });
        });
      }).not.toThrow();

      // Store should handle datasets
      expect(result.current.proposals.length).toBeGreaterThan(0);
    });

    it('should handle circular reference in proposal data', () => {
      const { result } = renderHook(() => useProposalStore());

      const circularProposal: any = {
        id: 'circular-test',
        type: 'charity_directory',
        title: 'Circular Test',
        author: 'Test Author',
        status: 'active',
        timeLeft: '7 days',
        yesPercentage: 50,
        noPercentage: 30,
        abstainPercentage: 20,
        createdAt: new Date(),
        votingEndsAt: new Date(),
        isAutoGenerated: false,
        votingType: 'approval',
      };

      // Create circular reference
      circularProposal.self = circularProposal;

      expect(() => {
        act(() => {
          result.current.addProposal(circularProposal);
        });
      }).not.toThrow();
    });
  });

  describe('Voting Error Handling', () => {
    it('should handle invalid vote submissions', () => {
      const { result } = renderHook(() => useProposalStore());

      expect(() => {
        act(() => {
          result.current.submitVote(null as any, 'yes', 1);
        });
      }).not.toThrow();

      expect(() => {
        act(() => {
          result.current.submitVote('valid-id', null as any, 1);
        });
      }).not.toThrow();

      expect(() => {
        act(() => {
          result.current.submitVote('', '', 0);
        });
      }).not.toThrow();
    });

    it('should handle voting on non-existent proposals', () => {
      const { result } = renderHook(() => useProposalStore());

      expect(() => {
        act(() => {
          result.current.submitVote('non-existent-proposal', 'yes', 1);
        });
      }).not.toThrow();

      // Store should remain stable
      expect(result.current.userVotes).toBeDefined();
    });

    it('should handle duplicate vote submissions', () => {
      const { result } = renderHook(() => useProposalStore());

      const proposalId = 'test-proposal';
      const vote = 'yes';

      expect(() => {
        act(() => {
          // Submit same vote multiple times
          result.current.submitVote(proposalId, vote, 1);
          result.current.submitVote(proposalId, vote, 1);
          result.current.submitVote(proposalId, vote, 1);
        });
      }).not.toThrow();

      // Store should handle duplicates gracefully
      expect(result.current.userVotes).toBeDefined();
    });

    it('should handle extremely long vote values', () => {
      const { result } = renderHook(() => useProposalStore());

      const longVoteValue = 'A'.repeat(100000);

      expect(() => {
        act(() => {
          result.current.submitVote('test-proposal', longVoteValue, 1);
        });
      }).not.toThrow();
    });

    it('should handle invalid voting power values', () => {
      const { result } = renderHook(() => useProposalStore());

      expect(() => {
        act(() => {
          result.current.submitVote('test-proposal', 'yes', NaN);
        });
      }).not.toThrow();

      expect(() => {
        act(() => {
          result.current.submitVote('test-proposal', 'yes', Infinity);
        });
      }).not.toThrow();

      expect(() => {
        act(() => {
          result.current.submitVote('test-proposal', 'yes', -1000000);
        });
      }).not.toThrow();
    });
  });

  describe('UserStore Error Handling', () => {
    it('should handle invalid user data', () => {
      const { result } = renderHook(() => useUserStore());

      expect(() => {
        act(() => {
          result.current.setUserId(null as any);
        });
      }).not.toThrow();

      expect(() => {
        act(() => {
          result.current.setUserId(undefined as any);
        });
      }).not.toThrow();

      // Store should remain stable
      expect(result.current.userId).toBeDefined();
    });

    it('should handle invalid preference updates', () => {
      const { result } = renderHook(() => useUserStore());

      expect(() => {
        act(() => {
          result.current.updatePreferences(null as any);
        });
      }).not.toThrow();

      expect(() => {
        act(() => {
          result.current.updatePreferences({
            theme: 'invalid_theme' as any,
            notifications: 'invalid_setting' as any,
          } as any);
        });
      }).not.toThrow();

      // Store should remain stable
      expect(result.current.preferences).toBeDefined();
    });

    it('should handle malformed notification data', () => {
      const { result } = renderHook(() => useUserStore());

      expect(() => {
        act(() => {
          result.current.addNotification(null as any);
        });
      }).not.toThrow();

      expect(() => {
        act(() => {
          result.current.addNotification({
            type: 'invalid-type' as any,
            title: undefined as any,
            message: null as any,
          });
        });
      }).not.toThrow();

      // Store should remain stable
      expect(result.current.notifications).toBeDefined();
    });

    it('should handle invalid voting record data', () => {
      const { result } = renderHook(() => useUserStore());

      expect(() => {
        act(() => {
          // Test with invalid voting record structure
          const invalidRecord = {
            proposalId: null,
            vote: undefined,
            timestamp: 'invalid-date',
          };

          // Since there's no direct method to add voting records in UserStore,
          // we'll test preference updates with invalid data
          result.current.updatePreferences({
            votingHistory: [invalidRecord],
          } as any);
        });
      }).not.toThrow();

      // Store should remain stable
      expect(result.current.preferences).toBeDefined();
    });

    it('should handle extremely large notification arrays', () => {
      const { result } = renderHook(() => useUserStore());

      const largeNotificationSet = Array.from({ length: 10000 }, (_, i) => ({
        id: `notification-${i}`,
        type: 'vote_reminder' as const,
        title: `Notification ${i}`,
        message: `Message ${i}`,
        timestamp: new Date(),
      }));

      expect(() => {
        act(() => {
          largeNotificationSet.forEach(notification => {
            result.current.addNotification(notification);
          });
        });
      }).not.toThrow();

      // Store should handle large datasets
      expect(result.current.notifications).toBeDefined();
    });
  });

  describe('CharityStore Error Handling', () => {
    it('should handle invalid charity data', () => {
      const { result } = renderHook(() => useCharityStore());

      expect(() => {
        act(() => {
          result.current.addCharity(null as any);
        });
      }).not.toThrow();

      expect(() => {
        act(() => {
          result.current.addCharity({
            id: 'invalid-charity',
            name: null,
            ein: 'invalid-ein',
            category: 'invalid_category' as any,
          } as any);
        });
      }).not.toThrow();

      // Store should remain stable
      expect(result.current.charities).toBeDefined();
    });

    it('should handle malformed search queries', () => {
      const { result } = renderHook(() => useCharityStore());

      expect(() => {
        act(() => {
          result.current.setCharities(null as any);
        });
      }).not.toThrow();

      expect(() => {
        act(() => {
          result.current.setCharities('' as any);
        });
      }).not.toThrow();

      expect(() => {
        act(() => {
          result.current.setCharities('   ' as any);
        });
      }).not.toThrow();
    });

    it('should handle invalid category filters', () => {
      const { result } = renderHook(() => useCharityStore());

      expect(() => {
        act(() => {
          result.current.setCategoryFilter('non-existent-category' as any);
        });
      }).not.toThrow();

      expect(() => {
        act(() => {
          result.current.setCategoryFilter(null as any);
        });
      }).not.toThrow();

      // Store should remain stable
      expect(result.current.categoryFilter).toBeDefined();
    });

    it('should handle extremely large charity datasets', () => {
      const { result } = renderHook(() => useCharityStore());

      const largeCharitySet = Array.from({ length: 10000 }, (_, i) => ({
        id: `charity-${i}`,
        name: `Charity ${i}`,
        category: 'veterans' as const,
        description: `Description ${i}`,
        website: `https://charity${i}.org`,
        ein: `12-345678${i % 10}`,
        isVerified: i % 2 === 0,
        rating: Math.floor(Math.random() * 5) + 1,
        totalDonations: Math.random() * 1000000,
        activeProposals: Math.floor(Math.random() * 10),
      }));

      expect(() => {
        act(() => {
          largeCharitySet.forEach(charity => {
            result.current.addCharity(charity as any);
          });
        });
      }).not.toThrow();

      // Store should handle large datasets
      expect(result.current.charities.length).toBeGreaterThan(0);
    });
  });

  describe('HolidayStore Error Handling', () => {
    it('should handle invalid holiday data', () => {
      const { result } = renderHook(() => useHolidayStore());

      expect(() => {
        act(() => {
          result.current.addHoliday(null as any);
        });
      }).not.toThrow();

      expect(() => {
        act(() => {
          result.current.addHoliday({
            id: 'invalid-holiday',
            name: null,
            date: 'invalid-date',
            type: 'invalid_type' as any,
          } as any);
        });
      }).not.toThrow();

      // Store should remain stable
      expect(result.current.holidays).toBeDefined();
    });

    it('should handle malformed holiday queries', () => {
      const { result } = renderHook(() => useHolidayStore());

      expect(() => {
        act(() => {
          result.current.getUpcomingHolidays(null as any);
        });
      }).not.toThrow();

      expect(() => {
        act(() => {
          result.current.getUpcomingHolidays(-1);
        });
      }).not.toThrow();

      expect(() => {
        act(() => {
          result.current.getUpcomingHolidays(13);
        });
      }).not.toThrow();
    });

    it('should handle invalid date ranges for holiday filtering', () => {
      const { result } = renderHook(() => useHolidayStore());

      expect(() => {
        act(() => {
          // Test with invalid date parameters
          result.current.getUpcomingHolidays(-1);
          result.current.getUpcomingHolidays(NaN);
          result.current.getUpcomingHolidays(Infinity);
        });
      }).not.toThrow();

      // Store should remain stable
      expect(result.current.holidays).toBeDefined();
    });

    it('should handle extremely large holiday datasets', () => {
      const { result } = renderHook(() => useHolidayStore());

      const largeHolidaySet = Array.from({ length: 10000 }, (_, i) => ({
        id: `holiday-${i}`,
        name: `Holiday ${i}`,
        date: new Date(2024, i % 12, (i % 28) + 1),
        category: 'federal' as const,
        description: `Description ${i}`,
        isEligibleForFunding: i % 2 === 0,
        fundingAmount: Math.random() * 100000,
        charityCategories: ['veterans'],
      }));

      expect(() => {
        act(() => {
          largeHolidaySet.forEach(holiday => {
            result.current.addHoliday(holiday as any);
          });
        });
      }).not.toThrow();

      // Store should handle large datasets
      expect(result.current.holidays.length).toBeGreaterThan(0);
    });

    it('should handle circular references in holiday data', () => {
      const { result } = renderHook(() => useHolidayStore());

      const circularHoliday: any = {
        id: 'circular-holiday',
        name: 'Circular Holiday',
        date: new Date(),
        category: 'federal',
        description: 'Test holiday with circular reference',
        isEligibleForFunding: true,
        fundingAmount: 50000,
        charityCategories: ['veterans'],
      };

      // Create circular reference
      circularHoliday.self = circularHoliday;

      expect(() => {
        act(() => {
          result.current.addHoliday(circularHoliday);
        });
      }).not.toThrow();

      // Store should handle circular references
      expect(result.current.holidays).toBeDefined();
    });
  });

  describe('Store State Consistency', () => {
    it('should maintain state consistency after multiple error operations', () => {
      const proposalStore = renderHook(() => useProposalStore());
      const userStore = renderHook(() => useUserStore());
      const charityStore = renderHook(() => useCharityStore());
      const holidayStore = renderHook(() => useHolidayStore());

      // Perform multiple error-prone operations
      expect(() => {
        act(() => {
          // Invalid operations on all stores
          proposalStore.result.current.addProposal(null as any);
          userStore.result.current.setUserId(undefined as any);
          charityStore.result.current.addCharity(null as any);
          holidayStore.result.current.addHoliday(null as any);

          // More invalid operations
          proposalStore.result.current.submitVote('', null as any, NaN);
          userStore.result.current.updatePreferences(null as any);
          charityStore.result.current.setCharities(null as any);
        });
      }).not.toThrow();

      // All stores should remain in a valid state
      expect(proposalStore.result.current.proposals).toBeDefined();
      expect(userStore.result.current.userId).toBeDefined();
      expect(charityStore.result.current.charities).toBeDefined();
      expect(holidayStore.result.current.holidays).toBeDefined();
    });

    it('should handle concurrent error operations', () => {
      const { result } = renderHook(() => useProposalStore());

      expect(() => {
        act(() => {
          // Simulate concurrent operations that might cause race conditions
          Promise.all([
            Promise.resolve(result.current.addProposal(null as any)),
            Promise.resolve(result.current.submitVote('invalid', 'yes', 1)),
            Promise.resolve(result.current.updateProposal('invalid', {})),
          ]);
        });
      }).not.toThrow();

      // Store should remain stable
      expect(result.current.proposals).toBeDefined();
    });
  });
});
