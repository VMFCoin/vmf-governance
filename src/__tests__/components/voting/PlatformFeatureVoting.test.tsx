import React from 'react';
import { render, screen, waitFor, fireEvent } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { PlatformFeatureVoting } from '@/components/voting/PlatformFeatureVoting';
import { useProposalStore } from '@/stores/useProposalStore';
import { PlatformFeatureProposal } from '@/types';

// Mock the store
jest.mock('@/stores/useProposalStore');

// Mock framer-motion
jest.mock('framer-motion', () => ({
  motion: {
    div: ({ children, ...props }: any) => <div {...props}>{children}</div>,
  },
}));

// Mock UI components
jest.mock('@/components/ui', () => ({
  Button: ({ children, ...props }: any) => (
    <button {...props}>{children}</button>
  ),
  Card: ({ children, ...props }: any) => <div {...props}>{children}</div>,
}));

jest.mock('@/components/ui/AnimatedTooltip', () => ({
  SimpleTooltip: ({ children, content }: any) => (
    <div title={content}>{children}</div>
  ),
  AdvancedTooltip: ({ children, content }: any) => (
    <div title={content}>{children}</div>
  ),
}));

jest.mock('@/components/proposals/shared/ProposalTypeIndicator', () => ({
  ProposalTypeIndicator: ({ type }: any) => (
    <div data-testid="proposal-type">{type}</div>
  ),
}));

jest.mock('@/lib/utils', () => ({
  cn: (...args: any[]) => args.filter(Boolean).join(' '),
}));

jest.mock('@/lib/animations', () => ({
  fadeInVariants: {
    initial: { opacity: 0 },
    enter: { opacity: 1 },
  },
}));

const mockProposalStore = useProposalStore as jest.MockedFunction<
  typeof useProposalStore
>;

const mockFeatureSpec = {
  title: 'Enhanced Voting Dashboard',
  description:
    'Improved user interface for voting on proposals with real-time updates and better accessibility',
  userStory:
    'As a DAO member, I want to easily view and vote on proposals with clear visual feedback',
  acceptanceCriteria: [
    'Display all active proposals in a clean, organized layout',
    'Allow voting with clear visual feedback and confirmation',
    'Show voting results in real-time with animated charts',
    'Ensure full accessibility compliance (WCAG 2.1 AA)',
    'Support mobile and desktop responsive design',
  ],
  technicalRequirements:
    'React components with TypeScript, Framer Motion animations, responsive CSS',
  priority: 'high' as const,
  estimatedEffort: '2-3 weeks',
  targetUsers: ['All DAO members', 'Mobile users', 'Accessibility users'],
  businessValue:
    'Improved user engagement and voting participation, better accessibility',
};

const mockProposal: PlatformFeatureProposal = {
  id: 'feature-1',
  type: 'platform_feature',
  title: 'Enhanced Voting Dashboard',
  author: '0x1234567890123456789012345678901234567890',
  status: 'active',
  timeLeft: '7 days',
  yesPercentage: 80,
  noPercentage: 10,
  abstainPercentage: 10,
  description:
    'Proposal to implement an enhanced voting dashboard for better user experience',
  createdAt: new Date('2024-01-01'),
  votingEndsAt: new Date('2024-01-10'),
  featureSpecification: mockFeatureSpec,
  implementationComplexity: 'medium',
  estimatedDevelopmentTime: '2-3 weeks',
  isAutoGenerated: false,
  votingType: 'approval',
};

describe('PlatformFeatureVoting Component', () => {
  const mockSubmitVote = jest.fn();
  const mockOnVoteSubmitted = jest.fn();

  beforeEach(() => {
    jest.clearAllMocks();

    mockProposalStore.mockReturnValue({
      submitVote: mockSubmitVote,
      proposals: [],
      addProposal: jest.fn(),
      updateProposal: jest.fn(),
      removeProposal: jest.fn(),
      getProposalById: jest.fn(),
      createHolidayCharityProposal: jest.fn(),
      createCharityDirectoryProposal: jest.fn(),
      createPlatformFeatureProposal: jest.fn(),
    });
  });

  describe('Basic Rendering', () => {
    it('renders with correct title and description', () => {
      render(<PlatformFeatureVoting proposal={mockProposal} />);

      expect(screen.getByText('Platform Feature Proposal')).toBeInTheDocument();
      expect(
        screen.getByText(
          'Review the feature specification and vote on implementation'
        )
      ).toBeInTheDocument();
    });

    it('displays feature title and description', () => {
      render(<PlatformFeatureVoting proposal={mockProposal} />);

      expect(screen.getByText('Enhanced Voting Dashboard')).toBeInTheDocument();
      expect(
        screen.getByText(
          'Improved user interface for voting on proposals with real-time updates and better accessibility'
        )
      ).toBeInTheDocument();
    });

    it('displays implementation details', () => {
      render(<PlatformFeatureVoting proposal={mockProposal} />);

      expect(screen.getByText('Enhanced Voting Dashboard')).toBeInTheDocument();
      expect(screen.getByText(/medium.*Complexity/)).toBeInTheDocument();
      expect(screen.getByText('2-3 weeks')).toBeInTheDocument();
    });
  });

  describe('Feature Specification Display', () => {
    it('displays user story', () => {
      render(<PlatformFeatureVoting proposal={mockProposal} />);

      expect(screen.getByText('User Story')).toBeInTheDocument();
      expect(
        screen.getByText(
          /As a DAO member, I want to easily view and vote on proposals with clear visual feedback/
        )
      ).toBeInTheDocument();
    });

    it('displays acceptance criteria', () => {
      render(<PlatformFeatureVoting proposal={mockProposal} />);

      expect(screen.getByText('Acceptance Criteria')).toBeInTheDocument();
      expect(
        screen.getByText(
          'Display all active proposals in a clean, organized layout'
        )
      ).toBeInTheDocument();
      expect(
        screen.getByText(
          'Allow voting with clear visual feedback and confirmation'
        )
      ).toBeInTheDocument();
      expect(
        screen.getByText(
          'Show voting results in real-time with animated charts'
        )
      ).toBeInTheDocument();
      expect(
        screen.getByText('Ensure full accessibility compliance (WCAG 2.1 AA)')
      ).toBeInTheDocument();
      expect(
        screen.getByText('Support mobile and desktop responsive design')
      ).toBeInTheDocument();
    });

    it('displays technical requirements', () => {
      render(<PlatformFeatureVoting proposal={mockProposal} />);

      expect(screen.getByText('Technical Requirements')).toBeInTheDocument();
      expect(
        screen.getByText(
          'React components with TypeScript, Framer Motion animations, responsive CSS'
        )
      ).toBeInTheDocument();
    });

    it('displays target users', () => {
      render(<PlatformFeatureVoting proposal={mockProposal} />);

      expect(screen.getByText('Target Users')).toBeInTheDocument();
      expect(screen.getByText('All DAO members')).toBeInTheDocument();
      expect(screen.getByText('Mobile users')).toBeInTheDocument();
      expect(screen.getByText('Accessibility users')).toBeInTheDocument();
    });

    it('displays business value', () => {
      render(<PlatformFeatureVoting proposal={mockProposal} />);

      expect(screen.getByText('Business Value')).toBeInTheDocument();
      expect(
        screen.getByText(
          'Improved user engagement and voting participation, better accessibility'
        )
      ).toBeInTheDocument();
    });
  });

  describe('Voting Considerations', () => {
    it('displays voting considerations section', () => {
      render(<PlatformFeatureVoting proposal={mockProposal} />);

      expect(screen.getByText('Voting Considerations')).toBeInTheDocument();
      expect(
        screen.getByText(/Does this feature align with VMF's mission and goals/)
      ).toBeInTheDocument();
      expect(
        screen.getByText(
          /Will this feature provide value to the veteran community/
        )
      ).toBeInTheDocument();
      expect(
        screen.getByText(
          /Are the technical requirements feasible and well-defined/
        )
      ).toBeInTheDocument();
      expect(
        screen.getByText(
          /Is the estimated development time reasonable for the complexity/
        )
      ).toBeInTheDocument();
      expect(
        screen.getByText(
          /Does the business value justify the development effort/
        )
      ).toBeInTheDocument();
    });
  });

  describe('Voting Actions', () => {
    it('renders all voting buttons', () => {
      render(<PlatformFeatureVoting proposal={mockProposal} />);

      expect(
        screen.getByRole('button', {
          name: /✅ Vote Yes - Approve Feature/i,
        })
      ).toBeInTheDocument();

      expect(
        screen.getByRole('button', {
          name: /❌ Vote No - Reject Feature/i,
        })
      ).toBeInTheDocument();

      expect(
        screen.getByRole('button', {
          name: /⚪ Abstain/i,
        })
      ).toBeInTheDocument();
    });

    it('submits Yes vote correctly', async () => {
      mockSubmitVote.mockResolvedValue(undefined);

      render(
        <PlatformFeatureVoting
          proposal={mockProposal}
          onVoteSubmitted={mockOnVoteSubmitted}
        />
      );

      const yesButton = screen.getByRole('button', {
        name: /✅ Vote Yes - Approve Feature/i,
      });

      fireEvent.click(yesButton);

      await waitFor(() => {
        expect(mockSubmitVote).toHaveBeenCalledWith(mockProposal.id, 'yes', 1);
      });

      expect(mockOnVoteSubmitted).toHaveBeenCalled();
    });

    it('submits No vote correctly', async () => {
      mockSubmitVote.mockResolvedValue(undefined);

      render(
        <PlatformFeatureVoting
          proposal={mockProposal}
          onVoteSubmitted={mockOnVoteSubmitted}
        />
      );

      const noButton = screen.getByRole('button', {
        name: /❌ Vote No - Reject Feature/i,
      });

      fireEvent.click(noButton);

      await waitFor(() => {
        expect(mockSubmitVote).toHaveBeenCalledWith(mockProposal.id, 'no', 1);
      });

      expect(mockOnVoteSubmitted).toHaveBeenCalled();
    });

    it('submits Abstain vote correctly', async () => {
      mockSubmitVote.mockResolvedValue(undefined);

      render(
        <PlatformFeatureVoting
          proposal={mockProposal}
          onVoteSubmitted={mockOnVoteSubmitted}
        />
      );

      const abstainButton = screen.getByRole('button', {
        name: /⚪ Abstain/i,
      });

      fireEvent.click(abstainButton);

      await waitFor(() => {
        expect(mockSubmitVote).toHaveBeenCalledWith(
          mockProposal.id,
          'abstain',
          1
        );
      });

      expect(mockOnVoteSubmitted).toHaveBeenCalled();
    });
  });

  describe('Loading States', () => {
    it('shows loading state during vote submission', async () => {
      mockSubmitVote.mockImplementation(
        () => new Promise(resolve => setTimeout(resolve, 1000))
      );

      render(<PlatformFeatureVoting proposal={mockProposal} />);

      const yesButton = screen.getByRole('button', {
        name: /✅ Vote Yes - Approve Feature/i,
      });

      fireEvent.click(yesButton);

      // Check that buttons show submitting text (multiple buttons will show this)
      await waitFor(() => {
        expect(screen.getAllByText('Submitting...').length).toBeGreaterThan(0);
      });
    });

    it('disables all buttons during submission', async () => {
      mockSubmitVote.mockImplementation(
        () => new Promise(resolve => setTimeout(resolve, 1000))
      );

      render(<PlatformFeatureVoting proposal={mockProposal} />);

      const yesButton = screen.getByRole('button', {
        name: /✅ Vote Yes - Approve Feature/i,
      });
      const noButton = screen.getByRole('button', {
        name: /❌ Vote No - Reject Feature/i,
      });
      const abstainButton = screen.getByRole('button', {
        name: /⚪ Abstain/i,
      });

      fireEvent.click(yesButton);

      await waitFor(() => {
        expect(yesButton).toBeDisabled();
        expect(noButton).toBeDisabled();
        expect(abstainButton).toBeDisabled();
      });
    });
  });

  describe('Error Handling', () => {
    it('handles vote submission errors gracefully', async () => {
      const consoleError = jest
        .spyOn(console, 'error')
        .mockImplementation(() => {});
      mockSubmitVote.mockRejectedValue(new Error('Network error'));

      render(<PlatformFeatureVoting proposal={mockProposal} />);

      const yesButton = screen.getByRole('button', {
        name: /✅ Vote Yes - Approve Feature/i,
      });

      fireEvent.click(yesButton);

      await waitFor(() => {
        expect(mockSubmitVote).toHaveBeenCalledWith(mockProposal.id, 'yes', 1);
      });

      // Verify error was logged
      expect(consoleError).toHaveBeenCalledWith(
        'Failed to submit vote:',
        expect.any(Error)
      );

      consoleError.mockRestore();
    });
  });

  describe('Edge Cases', () => {
    it('works without onVoteSubmitted callback', async () => {
      mockSubmitVote.mockResolvedValue(undefined);

      render(<PlatformFeatureVoting proposal={mockProposal} />);

      const yesButton = screen.getByRole('button', {
        name: /✅ Vote Yes - Approve Feature/i,
      });

      fireEvent.click(yesButton);

      await waitFor(() => {
        expect(mockSubmitVote).toHaveBeenCalledWith(mockProposal.id, 'yes', 1);
      });

      // Should not throw error even without callback
    });

    it('handles missing optional fields gracefully', () => {
      const minimalProposal: PlatformFeatureProposal = {
        id: 'minimal-1',
        type: 'platform_feature',
        title: 'Basic Feature',
        description: 'A basic feature description',
        status: 'active',
        author: 'test-author',
        timeLeft: '30 days',
        yesPercentage: 0,
        noPercentage: 0,
        abstainPercentage: 0,
        createdAt: new Date('2024-01-01T00:00:00Z'),
        votingEndsAt: new Date('2024-02-01T00:00:00Z'),
        featureSpecification: {
          title: 'Basic Feature',
          description: 'A basic feature description',
          userStory: 'As a user, I want basic functionality',
          acceptanceCriteria: ['Basic criteria'],
          technicalRequirements: 'Basic requirement',
          targetUsers: ['General users'],
          priority: 'medium',
          estimatedEffort: '1 week',
          businessValue: 'Basic value',
        },
        implementationComplexity: 'medium',
        estimatedDevelopmentTime: '1 week',
        isAutoGenerated: false,
        votingType: 'approval',
      };

      render(<PlatformFeatureVoting proposal={minimalProposal} />);

      expect(screen.getByText('Basic Feature')).toBeInTheDocument();
      expect(
        screen.getByText('A basic feature description')
      ).toBeInTheDocument();
      // Check for priority and complexity display
      expect(screen.getByText(/medium.*Priority/)).toBeInTheDocument();
      expect(screen.getByText(/medium.*Complexity/)).toBeInTheDocument();
    });
  });

  describe('Accessibility', () => {
    it('has proper button labels for screen readers', () => {
      render(<PlatformFeatureVoting proposal={mockProposal} />);

      expect(
        screen.getByRole('button', {
          name: /✅ Vote Yes - Approve Feature/i,
        })
      ).toBeInTheDocument();

      expect(
        screen.getByRole('button', {
          name: /❌ Vote No - Reject Feature/i,
        })
      ).toBeInTheDocument();

      expect(
        screen.getByRole('button', {
          name: /⚪ Abstain/i,
        })
      ).toBeInTheDocument();
    });

    it('has proper heading structure', () => {
      render(<PlatformFeatureVoting proposal={mockProposal} />);

      expect(
        screen.getByRole('heading', { name: /platform feature proposal/i })
      ).toBeInTheDocument();
      expect(
        screen.getByRole('heading', { name: /user story/i })
      ).toBeInTheDocument();
      expect(
        screen.getByRole('heading', { name: /acceptance criteria/i })
      ).toBeInTheDocument();
    });
  });
});
